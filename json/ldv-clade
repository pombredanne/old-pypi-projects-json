{
    "info": {
        "author": "Ilya Shchepetkov",
        "author_email": "ilya.shchepetkov@yandex.ru",
        "bugtrack_url": null,
        "classifiers": [
            "License :: OSI Approved :: Apache Software License",
            "Operating System :: Unix",
            "Programming Language :: Python :: 3",
            "Programming Language :: Python :: 3.4",
            "Programming Language :: Python :: 3.5",
            "Programming Language :: Python :: 3.6",
            "Programming Language :: Python :: 3.7",
            "Programming Language :: Python :: Implementation :: CPython"
        ],
        "description": ".. image:: https://travis-ci.org/17451k/clade.svg?branch=master\n    :target: https://travis-ci.org/17451k/clade\n    :alt: Build status\n.. image:: https://coveralls.io/repos/github/17451k/clade/badge.svg?branch=master\n    :target: https://coveralls.io/github/17451k/clade?branch=master\n    :alt: Code coverage information\n.. image:: https://img.shields.io/pypi/pyversions/clade.svg\n    :target: https://pypi.org/project/clade/\n    :alt: Supported versions of Python\n.. image:: https://img.shields.io/pypi/v/clade.svg\n    :target: https://pypi.org/project/clade\n    :alt: PyPi package version\n\nClade\n=====\n\nClade is a tool for intercepting build commands (stuff like compilation,\nlinking, mv, rm, and all other commands that are executed during build).\nIntercepted commands can be parsed (to search for input and output files,\nand options) and then used for various purposes:\n\n- generating `compilation database`_;\n- obtaining information about dependencies between source and object files;\n- obtaining information about the source code (source code querying);\n- generating function call graph;\n- running software verification tools;\n- visualization of all collected information;\n- *and for much more*.\n\n.. _compilation database: https://clang.llvm.org/docs/JSONCompilationDatabase.html\n\nThe interception of build commands is independent of the project type\nand used programming languages.\nHowever, all other functionality available in Clade IS dependent.\nCurrently only C projects are supported, but other languages and additional\nfunctionality can be supported through the built-in *extension mechanism*.\n\nPrerequisites\n-------------\n\nAn important part of Clade - a build commands intercepting library -\nis written in C and it needs to be compiled before use.\nIt will be performed automatically at the installation stage, but you will\nneed to install some prerequisites beforehand:\n\n- Python 3 (>=3.4)\n- cmake (>=3.3)\n- make\n- C **and** C++ compiler (gcc or clang)\n- *Linux only*: python3-dev (Ubuntu) or python3-devel (openSUSE) package\n\nOptional dependencies:\n\n- For obtaining information about the C code you will need CIF_\n  installed. CIF is an interface to Aspectator_ which in turn is a GCC\n  based tool that implements aspect-oriented programming for the C programming\n  language. You may download compiled CIF on `CIF releases`_ page.\n- Graphviz for some visualization capabilities\n- *Linux only*: gcc-multilib (Ubuntu) or gcc-32bit (openSUSE) package\n  to intercept build commands of projects leveraging multilib capabilities\n\n.. _CIF: https://github.com/17451k/cif\n.. _Aspectator: https://github.com/17451k/aspectator\n.. _CIF releases: https://github.com/17451k/cif/releases\n\nClade works on Linux and macOS.\nPartial support for Windows will be implemented soon.\n\nInstallation\n------------\n\nTo install the latest stable version just run the following command:\n\n.. code-block:: bash\n\n    $ pip3 install clade\n\nFor development purposes you may install Clade in \"editable\" mode\ndirectly from the repository (clone it on your computer beforehand):\n\n.. code-block:: bash\n\n    $ pip3 install -e .\n\nYou can check that Clade works as expected on your machine by running\nthe test suite from the repository:\n\n.. code-block:: bash\n\n    $ pytest\n\nHow to use\n----------\n\nAll functionality is available both as command-line scripts and\nas Python modules that you can import and use, so the following\nexamples will include both use cases.\n\nBuild command intercepting\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nClade can intercept the *exec* calls issued by the build tool for each build\ncommand.\nTo do this we have developed a shared library (called *libinterceptor*)\nthat redefine such exec functions: before creating a new process our\nexec functions store the information about the command into a separate file.\nThe library is than injected into the build process using\n*LD_PRELOAD* (Linux) and *DYLD_INSERT_LIBRARIES* (macOS) mechanisms provided by\nthe dynamic linker.\n\n.. image:: docs/pics/libinterceptor.png\n    :alt: An explanation of LD_PRELOAD\n\nIntercepting of build commands is quite easy: all you need is to\nwrap your main build command like this:\n\n.. code-block:: bash\n\n    $ clade-intercept make\n\nwhere *make* should be replaced by your project build command.\nThe output file called *cmds.txt* will be stored in the current directory\nand will contain all intercepted commands, one per line.\n\nYou can change the path to to the file where intercepted commands will be\nsaved using -o (--output) option:\n\n.. code-block:: bash\n\n    $ clade-intercept -o /work/cmds.txt make\n\nIn case the build process of your project consists of several independent\nsteps, you can still create one single *cmds.txt* file using\n-a (--append) option:\n\n.. code-block:: bash\n\n    $ clade-intercept make step_one\n    $ clade-intercept -a make step_two\n\nAs a result, build commands of the second make command will be appended\nto the *cmds.txt* file created previously.\n\nThere is an alternative *fallback* intercepting method that is based on\n*wrappers*. It can be used when LD_PRELOAD is unavailable:\n\n.. code-block:: bash\n\n    $ clade-intercept -f make\n\nUnfortunately, for now *wrappers* can't intercept commands that are executed\nbypassing the PATH environment variable: for example, *gcc* command can be\nintercepted, but calling directly to */usr/bin/gcc* cannot. We have plans\nto implement some workarounds to mitigate this issue.\n\nYou can intercept build commands from a python script:\n\n.. code-block:: python\n\n    from clade.intercept import Interceptor\n    i = Interceptor(command=[\"make\"], output=\"cmds.txt\", append=False, fallback=False)\n    i.execute()\n\nContent of *cmds.txt* file\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nLet's look at the simple makefile:\n\n.. code-block:: make\n\n    all:\n        gcc main.c -o main\n        rm main\n\nIf we try to intercept *make all* command,\nthe following *cmds.txt* file will be produced (on macOS):\n\n::\n\n    /work/simple_make||0||/usr/bin/make||make||all\n    /work/simple_make||1||/Library/Developer/CommandLineTools/usr/bin/make||/Library/Developer/CommandLineTools/usr/bin/make||all\n    /work/simple_make||2||/usr/bin/gcc||gcc||main.c||-o||main||-O3\n    /work/simple_make||3||/Library/Developer/CommandLineTools/usr/bin/gcc||/Library/Developer/CommandLineTools/usr/bin/gcc||main.c||-o||main||-O3\n    /work/simple_make||4||/usr/bin/xcrun||/usr/bin/xcrun||clang||main.c||-o||main||-O3\n    /work/simple_make||5||/Library/Developer/CommandLineTools/usr/bin/clang||/Library/Developer/CommandLineTools/usr/bin/clang||main.c||-o||main||-O3\n    /work/simple_make||6||/Library/Developer/CommandLineTools/usr/bin/clang||/Library/Developer/CommandLineTools/usr/bin/clang||-cc1||-triple||x86_64-apple-macosx10.14.0||-Wdeprecated-objc-isa-usage||-Werror=deprecated-objc-isa-usage||-emit-obj||-disable-free||-disable-llvm-verifier||-discard-value-names||-main-file-name||main.c||-mrelocation-model||pic||-pic-level||2||-mthread-model||posix||-mdisable-fp-elim||-fno-strict-return||-masm-verbose||-munwind-tables||-target-cpu||penryn||-dwarf-column-info||-debugger-tuning=lldb||-target-linker-version||409.12||-resource-dir||/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0||-O3||-fdebug-compilation-dir||/work/simple_make||-ferror-limit||19||-fmessage-length||150||-stack-protector||1||-fblocks||-fencode-extended-block-signature||-fobjc-runtime=macosx-10.14.0||-fmax-type-align=16||-fdiagnostics-show-option||-fcolor-diagnostics||-vectorize-loops||-vectorize-slp||-o||/var/folders/w7/d45mjl5d79v0hl9gqzzfkdgh0000gn/T/main-de88a6.o||-x||c||main.c\n    /work/simple_make||7||/Library/Developer/CommandLineTools/usr/bin/ld||/Library/Developer/CommandLineTools/usr/bin/ld||-demangle||-lto_library||/Library/Developer/CommandLineTools/usr/lib/libLTO.dylib||-dynamic||-arch||x86_64||-macosx_version_min||10.14.0||-o||main||/var/folders/w7/d45mjl5d79v0hl9gqzzfkdgh0000gn/T/main-de88a6.o||-lSystem||/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/lib/darwin/libclang_rt.osx.a\n    /work/simple_make||2||/bin/rm||rm||main\n\n\nYou can try to use *cmds.txt* file directly, but its format is not quite\nuser-friendly and is subject to change.\nIt is a good idea not to rely on the format of *cmds.txt* file\nand use the interface module instead:\n\n.. code-block:: python\n\n    from clade.cmds import get_all_cmds\n    cmds = get_all_cmds(\"cmds.txt\")\n\nwhere *cmds* is a list of dictionaries representing each intercepted command.\nFor example, dictionary that represents *gcc* command from the above makefile\nlooks like this:\n\n.. code-block:: json\n\n    {\n        \"command\": [\n            \"gcc\",\n            \"main.c\",\n            \"-o\",\n            \"main\",\n            \"-O3\"\n        ],\n        \"cwd\": \"/work/simple_make\",\n        \"id\": \"3\",\n        \"pid\": \"2\",\n        \"which\": \"/usr/bin/gcc\"\n    }\n\nwhere:\n\n- *command* - is intercepted command itself;\n- *cwd* - is a path to the directory where the command was executed;\n- *id* - is a unique identifier assigned to the command;\n- *pid* - is an identifier of the parent command\n  (command that executed the current one - in our example\n  it is an identifier of the make command);\n- *which* - path to an executable file that was executed\n  as a result of this command.\n\nIt should be noted that all other functionality available in Clade use\n*cmds.txt* file as input.\nDue to this you do not need to rebuild your project every time you want\nto use it - you can just use previously generated *cmds.txt* file.\n\nParsing of intercepted commands\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nOnce build commands are intercepted they can be parsed to search for input\nand output files, and options. Currently there are *extensions* in Clade\nfor parsing following commands:\n\n- C compilation commands (cc, gcc, clang, various cross compilers);\n- linker commands (ld);\n- assembler commands (as);\n- archive commands (ar);\n- move commands (mv);\n- object copy commands (objcopy, Linux only).\n\nThese extensions can be executed from command line through *clade-cc*,\n*clade-ld*, *clade-as*, *clade-ar*, *clade-mv*, *clade-objcopy* commands\nrespectively. They all have similar input interface and the format\nof output files, so let's just look at *clade-cc* command. It can be executed\nas follows:\n\n.. code-block:: bash\n\n    $ clade-cc cmds.txt\n\nAs a result, a working directory named *clade* will be created:\n\n::\n\n    clade/\n    \u251c\u2500\u2500 CC/\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 cmds.json\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 cmds/\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 deps/\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 opts/\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 unparsed/\n    \u251c\u2500\u2500 PidGraph/\n    \u2514\u2500\u2500 Storage/\n\nTop-level directories are in turn working directories of corresponding\nextensions that were executed inside *clade-cc* command.\n*CC* extension is the one we wanted to execute, but there are also\nother extensions - *PidGraph* and *Storage* - that were executed implicitly\nby *CC* because it depends on the results of their work.\nLet's skip them for now.\n\nInside *CC* directory there is a bunch of other directories and *cmds.json*\nfile with parsed compilation commands.\nAgain, it is a list of dictionaries representing each parsed command.\nLet's look at the parsed command from the above example:\n\n.. code-block:: json\n\n    {\n        \"command\":\"gcc\",\n        \"cwd\":\"/work/simple_make\",\n        \"id\":\"3\",\n        \"in\":[\n            \"main.c\"\n        ],\n        \"opts\":[\n            \"-O3\"\n        ],\n        \"out\":[\n            \"main\"\n        ]\n    }\n\nIts structure is quite simple: there is a list of input files,\na list of output files, a list of options, and some other info that is\nself-explanatory.\n\n*CC* extension also identify *dependencies* of the main source file\nfor each compilation command.\nDependencies are the names of all included header files,\neven ones included indirectly.\nClade stores them inside *deps* subfolder.\nFor example, dependencies of the parsed command with id=\"3\" can be found\nin *deps/3.json* file:\n\n::\n\n    [\n        \"/usr/include/secure/_common.h\",\n        \"/usr/include/sys/_types/_u_int32_t.h\",\n        \"/usr/include/machine/_types.h\",\n        \"/usr/include/sys/_types/_u_int16_t.h\",\n        \"/usr/include/_stdio.h\",\n        \"/usr/include/sys/cdefs.h\",\n        \"/usr/include/secure/_stdio.h\",\n        \"/usr/include/sys/_types/_size_t.h\",\n        \"/usr/include/sys/_types/_u_int8_t.h\",\n        \"/usr/include/stdio.h\",\n        \"/usr/include/sys/_types/_ssize_t.h\",\n        \"/usr/include/sys/_symbol_aliasing.h\",\n        \"/usr/include/sys/_types/_int32_t.h\",\n        \"/usr/include/sys/_pthread/_pthread_types.h\",\n        \"/usr/include/sys/_types/_int8_t.h\",\n        \"main.c\",\n        \"/usr/include/sys/_types/_int16_t.h\",\n        \"/usr/include/sys/_types/_uintptr_t.h\",\n        \"/usr/include/sys/_types/_null.h\",\n        \"/usr/include/sys/_types/_off_t.h\",\n        \"/usr/include/sys/stdio.h\",\n        \"/usr/include/_types.h\",\n        \"/usr/include/AvailabilityInternal.h\",\n        \"/usr/include/sys/_types/_va_list.h\",\n        \"/usr/include/Availability.h\",\n        \"/usr/include/sys/_posix_availability.h\",\n        \"/usr/include/sys/_types/_u_int64_t.h\",\n        \"/usr/include/sys/_types/_intptr_t.h\",\n        \"/usr/include/sys/_types.h\",\n        \"/usr/include/sys/_types/_int64_t.h\",\n        \"/usr/include/i386/_types.h\",\n        \"/usr/include/i386/types.h\",\n        \"/usr/include/machine/types.h\"\n    ]\n\nBesides dependencies, all other parsed commands (ld, mv, and so on)\nwill also look this way: as a list of dictionaries representing each\nparsed command, with \"command\", \"id\", \"in\", \"opts\" and \"out\" fields.\n\n*CC* extension (and all others, of course) can also be imported and used\nas a Python module:\n\n.. code-block:: python\n\n    from clade.extensions.cc import CC\n\n    # Initialize extension with a path to the working directory\n    c = CC(work_dir=\"clade\")\n\n    # Execute parsing of intercepted commands\n    # This step can be skipped if commands are already parsed\n    # and stored in the working directory\n    c.parse(\"cmds.txt)\n\n    # Get a list of all parsed commands\n    parsed_cmds = c.load_all_cmds()\n    for cmd in parsed_cmds:\n        # Get a list of dependencies\n        deps = c.load_deps_by_id(cmd[\"id\"])\n        ...\n\nPid graph\n~~~~~~~~~\n\nEach intercepted command, except for the first one, is executed by another,\nparent command. For example, *gcc* internally executes\n*cc1* and *as* commands, so *gcc* is their parent.\nClade knows about this connection and tracks it by assigning to each intercepted\ncommand two attributes: a unique identifier (id) and identifier of its parent\n(pid).\nThis information is stored in the *pid graph* and can be obtained using\n*clade-pid-graph* command line tool:\n\n.. code-block:: bash\n\n    $ clade-pid-graph cmds.txt\n    $ tree clade -L 2\n\n    clade\n    \u2514\u2500\u2500 PidGraph\n     \u00a0\u00a0 \u251c\u2500\u2500 pid_by_id.json\n     \u00a0\u00a0 \u2514\u2500\u2500 pid_graph.json\n\nTwo files will be generated. First one - *pid_by_id.json* - is a simple\nmapping from ids to their pids and looks like this:\n\n.. code-block:: json\n\n    {\n        \"1\": \"0\",\n        \"2\": \"1\",\n        \"3\": \"2\",\n        \"4\": \"2\",\n        \"5\": \"1\"\n    }\n\nAnother one - *pid_graph.json* - stores information about all parent commands\nfor a given id:\n\n.. code-block:: json\n\n    {\n        \"1\": [\"0\"],\n        \"2\": [\"1\", \"0\"],\n        \"3\": [\"2\", \"1\", \"0\"],\n        \"4\": [\"2\", \"1\", \"0\"],\n        \"5\": [\"1\", \"0\"]\n    }\n\n*Pid graph* can be imported and used as a Python module:\n\n.. code-block:: python\n\n    from clade.extensions.pid_graph import PidGraph\n\n    # Initialize extension with a path to the working directory\n    c = PidGraph(work_dir=\"clade\")\n\n    # Execute parsing of intercepted commands\n    # This step can be skipped if commands are already parsed\n    # and stored in the working directory\n    c.parse(\"cmds.txt)\n\n    # Get all information\n    pid_by_id = c.load_pid_by_id()\n    pid_graph = c.load_pid_graph()\n\nOther extensions use *pid graph* to filter *duplicate* commands.\nFor example, on macOS executing \"*gcc main.c*\" command leads to the\nchain of execution of the following commands:\n\n- /usr/bin/gcc main.c\n- /Library/Developer/CommandLineTools/usr/bin/gcc main.c\n- /usr/bin/xcrun clang main.c\n- /Library/Developer/CommandLineTools/usr/bin/clang main.c\n- /Library/Developer/CommandLineTools/usr/bin/clang -cc1 ...\n\nSo, for a single compilation command, several commands will be actually\nintercepted. You probably need only one of them (the very first one),\nso Clade filter all *duplicate* ones using *pid graph*: Clade simply\ndo not parse all child commands of already parsed command.\nThis behavior is of course configurable and can be disabled.\n\n*Pid graph* can be visualized with Graphviz using one of\nthe configuration options:\n\n.. image:: docs/pics/pid_graph.png\n    :alt: An example of the pid graph\n\nNote: *pid graph* can be used with any project\n(not only with ones written in C).\n\nCommand graph\n~~~~~~~~~~~~~\n\nClade can connect commands by their input and output files.\nThis information is stored in the *command graph* and can be obtained using\n*clade-cmd-graph* command line tool.\n\nTo appear in the *command graph* an intercepted command needs to be parsed\nto search for input and output files.\nBy default only commands parsed by *CC*, *LD* and *MV* extensions\nare parsed and appeared in the *command graph*.\nThis behavior can be changed via configuration, which will be described below.\n\n\nLet's consider the following makefile:\n\n.. code-block:: make\n\n    all:\n        gcc -S main.c -o main.s  # id = 1\n        as main.s -o main.o      # id = 2\n        mv main.o main           # id = 3\n\nUsing *clade-cmd-graph* these commands can be connected:\n\n.. code-block:: bash\n\n    $ clade-pid-graph cmds.txt\n\n    clade/\n    \u251c\u2500\u2500 CmdGraph/\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 cmd_graph.json\n    \u251c\u2500\u2500 CC/\n    \u251c\u2500\u2500 LD/\n    \u251c\u2500\u2500 MV/\n    \u251c\u2500\u2500 PidGraph/\n    \u2514\u2500\u2500 Storage/\n\nwhere *cmd_graph.json* looks like this (commands are represented by their\nidentifiers and the type of extensions that parsed it):\n\n.. code-block:: json\n\n    {\n        \"1\":{\n            \"type\": \"CC\",\n            \"used_by\": [\"2\", \"3\"],\n            \"using\": []\n        },\n        \"2\":{\n            \"type\": \"AS\",\n            \"used_by\": [\"3\"],\n            \"using\": [\"1\"]\n        },\n        \"3\":{\n            \"type\": \"MV\",\n            \"used_by\": [],\n            \"using\": [\"1\", \"2\"]\n        }\n    }\n\n*Command graph* can be imported and used as a Python module:\n\n.. code-block:: python\n\n    from clade.extensions.cmd_graph import CmdGraph\n\n    # Initialize extension with a path to the working directory\n    c = CmdGraph(work_dir=\"clade\")\n\n    # Execute parsing of intercepted commands\n    # This step can be skipped if commands are already parsed\n    # and stored in the working directory\n    c.parse(\"cmds.txt)\n\n    # Get the command graph\n    cmd_graph = c.load_cmd_graph()\n\n*Command graph* can be visualized with Graphviz using one of\nthe configuration options:\n\n.. image:: docs/pics/cmd_graph.png\n    :alt: An example of the command graph\n\nSource graph\n~~~~~~~~~~~~\n\nFor a given source file Clade can show in which commands this file\nis compiled, and in which commands it is indirectly used.\nThis information is called *source graph* and can be generated\nusing *clade-src-graph* command line utility:\n\n.. code-block:: bash\n\n    $ clade-src-graph cmds.txt\n\n    clade/\n    \u251c\u2500\u2500 SrcGraph/\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 src_graph.json\n    \u251c\u2500\u2500 CmdGraph/\n    \u251c\u2500\u2500 CC/\n    \u251c\u2500\u2500 LD/\n    \u251c\u2500\u2500 MV/\n    \u251c\u2500\u2500 PidGraph/\n    \u2514\u2500\u2500 Storage/\n\n*Source graph* for the Makefile presented in the *command graph* section above\nwill be located in the *src_graph.json* file and look like this:\n\n.. code-block:: json\n\n    {\n        \"/usr/include/stdio.h\": {\n            \"compiled_in\": [\"1\"],\n            \"loc\": 414,\n            \"used_by\": [\"2\", \"3\"]\n        },\n        \"main.c\":{\n            \"compiled_in\": [\"1\"],\n            \"loc\": 5,\n            \"used_by\": [\"2\", \"3\"],\n        },\n        \"main.s\":{\n            \"compiled_in\": [\"2\"],\n            \"loc\": 20,\n            \"used_by\": [\"3\"],\n        }\n    }\n\nFor simplicity information about other files has been removed from\nthe presented *source graph*.\nAs always, commands are represented through their unique identifiers.\n*loc* field contains information about the size of the source file:\nnumber of the lines of code.\n\n*Source graph* can be imported and used as a Python module:\n\n.. code-block:: python\n\n    from clade.extensions.src_graph import SrcGraph\n\n    # Initialize extension with a path to the working directory\n    c = SrcGraph(work_dir=\"clade\")\n\n    # Execute parsing of intercepted commands\n    # This step can be skipped if commands are already parsed\n    # and stored in the working directory\n    c.parse(\"cmds.txt)\n\n    # Get the source graph\n    src_graph = c.load_src_graph()\n\nCall graph\n~~~~~~~~~~\n\nClade can generate function *call graph* for a given project written in C.\nThis requires CIF installed on your computer, and path to its bin directory\nadded to the PATH environment variable.\n\n*Call graph* can be generated through command line utility *clade-callgraph*:\n\n.. code-block:: bash\n\n    $ clade-callgraph cmds.txt\n\n    clade/\n    \u251c\u2500\u2500 Callgraph/\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 callgraph/\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 callgraph.json\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 calls_by_ptr.json\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 used_in.json\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 err.log\n    \u251c\u2500\u2500 CC/\n    \u251c\u2500\u2500 LD/\n    \u251c\u2500\u2500 MV/\n    \u251c\u2500\u2500 PidGraph/\n    \u251c\u2500\u2500 Info/\n    \u251c\u2500\u2500 Functions/\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 functions_by_file/\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 functions_by_file.json\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 functions.json\n    \u2514\u2500\u2500 Storage/\n\n*Call graph* itself is stored inside *callgraph.json* file and can be\nrather large. Let's look at a small part of the call graph generated for\nthe Linux kernel:\n\n.. code-block:: json\n\n    {\n        \"drivers/net/usb/asix_common.c\": {\n            \"asix_get_phy_addr\": {\n                \"called_in\": {\n                    \"drivers/net/usb/asix_devices.c\": {\n                        \"ax88172_bind\": {\n                            \"242\": {\"match_type\" : 1}\n                        },\n                        \"ax88178_bind\": {\n                            \"809\": {\"match_type\" : 1}\n                        }\n                    }\n                },\n                \"calls\": {\n                    \"drivers/net/usb/asix_common.c\": {\n                        \"asix_read_phy_addr\": {\n                            \"235\": {\"match_type\" : 5}\n                        }\n                    }\n                },\n                \"type\": \"global\"\n            }\n        }\n    }\n\nThere is \"drivers/net/usb/asix_common.c\" file with definition of the\n\"asix_get_phy_addr\" function. This function is called in the\n\"drivers/net/usb/asix_devices.c\" file by \"ax88172_bind\" function on line\n\"242\" and by \"ax88178_bind\" function on line \"809\". \"match_type\" is an internal\ninformation needed for debug purposes. Also this function calls \"asix_read_phy_addr\"\nfile from the \"drivers/net/usb/asix_common.c\" file on the line \"235\".\n\nAll functions that call \"asix_get_phy_addr\" function or are called by it are\nalso present in the *call graph*, but were excluded from the above example.\n\n*Callgraph* extension uses \"Function\" extension to get information about\nfunction definitions and declarations.\nThey are stored in the *functions.json* file:\n\n.. code-block:: json\n\n    {\n        \"asix_get_phy_addr\": {\n            \"drivers/net/usb/asix_common.c\": {\n                \"declarations\": {\n                    \"drivers/net/usb/asix.h\": {\n                        \"line\": \"204\",\n                        \"signature\": \"int asix_get_phy_addr(struct usbnet *);\",\n                        \"type\": \"global\"\n                    }\n                },\n                \"line\": \"232\",\n                \"signature\": \"int asix_get_phy_addr(struct usbnet *dev);\",\n                \"type\": \"global\"\n            }\n    }\n\nFor each function definition there is information about corresponding\ndeclaration, line numbers in which the definition and declaration are located,\nfunction signature and type (global or static).\n\n*Callgraph* and *Functions* can be imported and used as Python modules:\n\n.. code-block:: python\n\n    from clade.extensions.callgraph import Callgraph\n    from clade.extensions.functions import Functions\n\n    # Initialize extension with a path to the working directory\n    c = Callgraph(work_dir=\"clade\")\n\n    # Execute parsing of intercepted commands\n    # This step can be skipped if commands are already parsed\n    # and stored in the working directory\n    c.parse(\"cmds.txt)\n\n    # Get the call graph\n    callgraph = c.load_callgraph()\n\n    # Usage looks quite ugly, yes\n    # This will be improved\n    for file in callgraph:\n        for func in callgraph[file]:\n            for caller_file in callgraph[file][func][\"called_in\"]:\n                for caller_func in callgraph[file][func][\"called_in\"][caller_file]:\n                    for call_line in callgraph[file][func][\"called_in\"][caller_file][caller_func]:\n                        ...\n\n            for called_file in callgraph[file][func][\"calls\"]:\n                for called_func in callgraph[file][func][\"calls\"][called_file]:\n                    for call_line in callgraph[file][func][\"calls\"][called_file][called_func]:\n                        ...\n\n    f = Functions(work_dir=\"clade\")\n    functions = f.load_functions()\n    # The usage is quite similar, so it is omitted\n    ...\n\nCompilation database\n~~~~~~~~~~~~~~~~~~~~\n\nCommand line tool for generating compilation database has a different\ninterface, compared to most other command line tools available in Clade.\nIn that regard it's more like *clade-intercept* command. Compilation\ndatabase can be generated using *clade* command:\n\n.. code-block:: bash\n\n    $ clade make\n\nwhere *make* should be replaced by your project build command.\nAs a result your project will be build and the *compile_commands.json*\nfile will be created in the current directory.\n\nIf you have *cmds.txt* file you can skip the build process and get\n*compile_comands.json* much faster:\n\n.. code-block:: bash\n\n    $ clade -c cmds.txt\n\nOther options are available through --help option.\n\n*Compilation database* can be imported and used as a Python module:\n\n.. code-block:: python\n\n    from clade.intercept import Interceptor\n    from clade.extensions.cdb import CDB\n\n    # Initialize extension with a path to the working directory\n    c = CDB(work_dir=\"clade\")\n\n    # Intercept build commands\n    # This step can be skipped if build commands are already intercepted\n    cmds_txt = \"cmds.txt\"\n    i = Interceptor(command=[\"make\"], output=cmds_txt)\n    i.execute()\n\n    # Generate compilation database\n    # This step can be skipped if compilation database is already generated\n    # and stored in the working directory\n    c.parse(cmds_txt)\n\n    # Get generated compilation database\n    compilation_database = c.load_cdb()\n\nConfiguration\n-------------\n\nThere is a bunch of options that can be changed to alter the behaviour\nof various tools available in Clade. If you execute these tools from the\ncommand line (tools like *clade-cc*, *clade-callgraph*, *clade-cmd-graph*,\nand so on), then the configuration can be passed via the \"-c\" option like this:\n\n.. code-block:: bash\n\n    $ clade-cc -c conf.json cmds.txt\n\nwhere *conf.json* is a json file with some configuration options:\n\n.. code-block:: json\n\n    {\n        \"PidGraph.as_picture\": true,\n        \"CmdGraph.requires\": [\n            \"CC\",\n            \"LD\",\n            \"MV\",\n            \"AR\",\n            \"Objcopy\"\n        ],\n        \"CC.which_list\": [\"/usr.bin.gcc\", \"^.*clang$\"]\n    }\n\nThe configuration can be also passed as a Python dictionary:\n\n.. code-block:: python\n\n    from clade.extensions.cc import CC\n\n    conf = {\"PidGraph.as_picture\": True}\n    c = CC(work_dir=\"clade\", conf=conf)\n\nwhich list\n~~~~~~~~~~\n\nLet's highlight some notable configuration options and let's start with\noptions for extensions that parse intercepted commands to search for input\nand output files, and options. These extensions need to know which commands\nto parse. They have a list of predefined regular expressions that they try\nto match with the *which* field of an intercepted command.\nFor example, *CC* extension have the following list:\n\n.. code-block:: python\n\n    which_list = [\n        r\"^.*cc$\",\n        r\"^.*[mg]cc(-?\\d+(\\.\\d+){0,2})?$\",\n        r\"^.*clang(-?\\d+(\\.\\d+){0,2})?$\"\n    ]\n\nObviously, execution of */usr/bin/gcc* will be matched, as well as\n*/usr/bin/clade*, or */usr/local/bin/powerpc-elf-gcc-7*, so all such commands\nwill be treated as compilation commands and parsed accordingly.\nSometimes this list is not enough, so there is an option to change it:\n\n::\n\n    \"CC.which_list\": [\"regexp_to_match_your_compiler\"]\n\nOptions for other such extensions look the same, you just need to replace *CC*\nby the name of the extension, so, for example, \"LD.which_list\" will be the\noption to change the list of regexes for *LD* extension.\n\nVisualization options\n~~~~~~~~~~~~~~~~~~~~~\n\nCurrently there are two small options to visualize *pid graph* and *cmd graph*\nusing Graphviz:\n\n.. code-block:: json\n\n    {\n        \"PidGraph.as_picture\": true,\n        \"CmdGraph.as_picture\": true\n    }\n\nIf they are set, then next to *pid_graph.json* and *cmd_graph.json* files\nrespectively pdf files containing Graphviz output will appear.\n\nList of commands to parse\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you want to generate *command graph*, or *source graph*, or *call graph*,\nthen you need to specify which commands to parse via \"CmdGraph.requires\"\noption. If you want to parse all commands that are supported now, then\nthe value of this option will be:\n\n.. code-block:: json\n\n    {\n        \"CmdGraph.requires\": [\"CC\", \"LD\", \"MV\", \"AR\", \"Objcopy\"]\n    }\n\nPresets\n~~~~~~~\n\nThere is predefined set of options for the following projects that can be used\nin addition to user-defined configuration:\n\n- Linux kernel (preset linux_kernel)\n- Busybox (presets busybox_linux, busybox_macos)\n- Apache (presets apache_linux, apache_macos)\n\nIf you want to execute Clade on one of these projects then it might be a *good\nidea* to use this presets, since they will definitely save you from having\nto deal with various problems and mess with the configuration:\n\n.. code-block:: bash\n\n    $ clade-cc -p linux_kernel cmds.txt\n\nor\n\n.. code-block:: python\n\n    from clade.extensions.cc import CC\n\n    c = CC(work_dir=\"clade\", preset=\"linux_kernel\")\n\nTroubleshooting\n---------------\n\nFile with intercepted commands is empty\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAccess control mechanisms on different operating systems might disable\nlibrary injection that is used by Clade to intercept build commands:\n\n- SELinux on Fedora, CentOS, RHEL;\n- System Integrity Protection on macOS;\n- Mandatory Integrity Control on Windows (disables similar mechanisms)\n\nA solution is to use *fallback* intercepting mechanism that is based on\n*wrappers*.\n\nFile with intercepted commands is not complete\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSometimes some commands are intercepted, so file *cmds.txt* is present and not\nempty, but other commands are clearly missing.\nSuch behaviour should be reported so the issue can be fixed, but until then\nyou can try to use *fallback* intercepting mechanism that is based on\n*wrappers*.\n\nWrong ELF class\n~~~~~~~~~~~~~~~\nBuild command intercepting may result in the following error:\n\n::\n\n    ERROR: ld.so: object 'libinterceptor.so' from LD_PRELOAD cannot be preloaded (wrong ELF class: ELFCLASS64): ignored.\n\nIt is because your project leverages multilib capabilities, but\n*libinterceptor* library that is used to intercept build commands is\ncompiled without multilib support.\nYou need to install *gcc-multilib* (Ubuntu) or *gcc-32bit* (openSUSE) package\nand **reinstall Clade**. *libinterceptor* library will be recompiled and your\nissue will be fixed.\n\nNot all intercepted compilation commands are parsed\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe reason is because *CC* extension that parse intercepted commands cannot\nidentify a command as a compilation command. You can help it by specifying\n\"CC.which_list\" configuration option, in which you should write a list of\nregexes that will match your compiler. For example, if path to your compiler\nis *~/.local/bin/c_compiler*, than \"CC.which_list\" may be set like this:\n\n::\n\n    \"CC.which_list\": [\"^.*?c_compiler$\"]\n\nIf you want to parse not only commands executed by your compiler, but by system\n*gcc* as well, then you can add it to the list too:\n\n::\n\n    \"CC.which_list\": [\"^.*?c_compiler$\", \"\"^.*gcc$\"]\n\nHow to set configuration option is described in *Configuration* section of\nthis readme.\n\nCompilation database miss some commands\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSame as above.\n\nCommand graph is not connected properly\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nMost certainly it is due to the fact that some type of commands is unparsed.\nIf there is an extension in Clade that can parse them, then you will need\nto specify it via the option \"CmdGraph.requires\":\n\n.. code-block:: json\n\n    {\n        \"CmdGraph.requires\": [\"CC\", \"LD\", \"MV\", \"AR\", \"Objcopy\"]\n    }\n\nOtherwise such extension should be developed.\n\nSimilar problems with the *source graph* and the *call graph* can be fixed\nvia the same option, since they use the *command graph* internally.\n\nAcknowledgments\n---------------\n\nClade is inspired by the Bear_ project created by `L\u00e1szl\u00f3 Nagy`_.\n\n.. _Bear: https://github.com/rizsotto/Bear\n.. _L\u00e1szl\u00f3 Nagy: https://github.com/rizsotto",
        "description_content_type": "",
        "docs_url": null,
        "download_url": "",
        "downloads": {
            "last_day": -1,
            "last_month": -1,
            "last_week": -1
        },
        "home_page": "https://github.com/17451k/clade",
        "keywords": "",
        "license": "LICENSE.txt",
        "maintainer": "",
        "maintainer_email": "",
        "name": "ldv-clade",
        "package_url": "https://pypi.org/project/ldv-clade/",
        "platform": "",
        "project_url": "https://pypi.org/project/ldv-clade/",
        "project_urls": {
            "Homepage": "https://github.com/17451k/clade"
        },
        "release_url": "https://pypi.org/project/ldv-clade/2.0.post3/",
        "requires_dist": null,
        "requires_python": ">=3.4",
        "summary": "",
        "version": "2.0.post3"
    },
    "last_serial": 4953754,
    "releases": {
        "2.0.post1": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "401da73a9598780f202198fba318e1f0",
                    "sha256": "80e4762a6942e51379e845eadd06ed81505bcac31193d5689877dcef56d9af25"
                },
                "downloads": -1,
                "filename": "ldv-clade-2.0.post1.tar.gz",
                "has_sig": false,
                "md5_digest": "401da73a9598780f202198fba318e1f0",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": ">=3.4",
                "size": 984294,
                "upload_time": "2018-10-24T09:05:55",
                "url": "https://files.pythonhosted.org/packages/67/bf/f6964eb6664bb2e8ed85f195b18c7a7c953b19676a812816a4036d51ed37/ldv-clade-2.0.post1.tar.gz"
            }
        ],
        "2.0.post2": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "237f216f73dc0eb73ced1c35ffe0cfb4",
                    "sha256": "2aa190f4e151bf3da6692177e265e23538794d942e3962b266540a48ef05dd8d"
                },
                "downloads": -1,
                "filename": "ldv_clade-2.0.post2-py3.6.egg",
                "has_sig": false,
                "md5_digest": "237f216f73dc0eb73ced1c35ffe0cfb4",
                "packagetype": "bdist_egg",
                "python_version": "3.6",
                "requires_python": ">=3.4",
                "size": 164911,
                "upload_time": "2018-10-24T09:53:33",
                "url": "https://files.pythonhosted.org/packages/22/cb/2f68558e3800eb1f1562c876360fab5e683ca647d25868853f002fdfe22f/ldv_clade-2.0.post2-py3.6.egg"
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "60751d341026eb9f6bebb112239a95ff",
                    "sha256": "b5403b683a71506f6791b980dfd3ee60cbf8ae86df8fabe98f8464c80ee71b3c"
                },
                "downloads": -1,
                "filename": "ldv-clade-2.0.post2.tar.gz",
                "has_sig": false,
                "md5_digest": "60751d341026eb9f6bebb112239a95ff",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": ">=3.4",
                "size": 977045,
                "upload_time": "2018-10-24T09:53:35",
                "url": "https://files.pythonhosted.org/packages/a6/37/fbd9ba6df837e03cd73461c6ba7e2da21bb35cb680c71a111ff08fbe4a05/ldv-clade-2.0.post2.tar.gz"
            }
        ],
        "2.0.post3": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "efa1893a4d226f2cc2ad091b1b9e59a5",
                    "sha256": "2acc5ac79cc3eb28b06c3ec852d19a98fedca954e043dd8f8fe847ac140ff106"
                },
                "downloads": -1,
                "filename": "ldv-clade-2.0.post3.tar.gz",
                "has_sig": false,
                "md5_digest": "efa1893a4d226f2cc2ad091b1b9e59a5",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": ">=3.4",
                "size": 982108,
                "upload_time": "2019-03-18T12:46:58",
                "url": "https://files.pythonhosted.org/packages/24/0a/97a8e65b10075b6849021117b3bf65e921efde43f306168da25708a50551/ldv-clade-2.0.post3.tar.gz"
            }
        ]
    },
    "urls": [
        {
            "comment_text": "",
            "digests": {
                "md5": "efa1893a4d226f2cc2ad091b1b9e59a5",
                "sha256": "2acc5ac79cc3eb28b06c3ec852d19a98fedca954e043dd8f8fe847ac140ff106"
            },
            "downloads": -1,
            "filename": "ldv-clade-2.0.post3.tar.gz",
            "has_sig": false,
            "md5_digest": "efa1893a4d226f2cc2ad091b1b9e59a5",
            "packagetype": "sdist",
            "python_version": "source",
            "requires_python": ">=3.4",
            "size": 982108,
            "upload_time": "2019-03-18T12:46:58",
            "url": "https://files.pythonhosted.org/packages/24/0a/97a8e65b10075b6849021117b3bf65e921efde43f306168da25708a50551/ldv-clade-2.0.post3.tar.gz"
        }
    ]
}